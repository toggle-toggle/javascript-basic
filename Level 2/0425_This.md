# DOM & BOM

## 목차

- [콜백 함수 내의 this에 대해서 아는대로 설명해주세요](#1)
- [명시적 바인딩(call, apply, bind)에 대해 설명해 보세요.](#2)
- [객체의 메서드를 외부 변수에 할당하거나 함수의 인수로 전달하면 바인딩된 this가 사라지는 이유를 설명하세요.](#3)
- [생성자 함수의 동작 방식을 this와 함께 설명해주세요.](#4)
- [this 바인딩에 대해서 아는대로 설명하세요.](#5)
- [화살표 함수에서의 this에 대해 설명해주세요.](#6)

---

## <a name="1"></a>콜백 함수 내의 this에 대해서 아는대로 설명해주세요.
- 어떤 객체의 메서드로 있던 함수가 인자로 전달될 경우에는 객체의 메서드가 아닌 함수자체로 전달된다.
콜백함수 내부에서의 this는 해당 콜백함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조한다.

- 콜백함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 콜백함수의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역 객체를 참조한다.
- 콜백함수 내부에서의 this는 해당 콜백함수의 제어권을 넘겨받은 함수가 정의한 바에 따르는데, 만약 정의하지 않은 경우에는 전역객체를 참조합니다.
- 콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩됩니다.



## <a name="2"></a>명시적 바인딩(call, apply, bind)에 대해 설명해 보세요.
- 자바스크립트에서는 메서드 내의 내부 함수 호출 패턴을 정의해 놓지 않았기 때문에, 내부 함수의 경우 일반 함수로 취급되어 함수 호출 패턴 규칙에 따라 this는 전역 객체에 바인딩된다. 이러한 this 바인딩의 한계를 극복하기 위해 제공되는 메서드가 call, apply, bind이다.
- **Call, Apply, Bind** 메서드 사용 시, 메서드에 첫 번째 인수로 전달하는 객체에 바인딩 된다.
    - Call 메서드는 함수를 실행하고, 첫 번째 인자에 this를 바인딩하며, 이후의 값을 함수의 인자로 전달한다.
    - Apply 메서드는 함수를 실행하고, 첫 번째 인자에 this를 바인딩하며, 이후의 값을 배열의 형태로 받아 차례로 함수의 인자로 전달한다.
    - bind 메서드는 함수를 실행하지 않으며, 첫 번째 인자에 this를 바인딩한 새로운 함수를 반환한다. 반환된 새로운 함수를 실행해야 원본 함수가 실행된다. (반환되는 '새로운 함수'는 특수 객체이다. 함수처럼 호출할 수 있지만 함수는 아닌 다른 객체)

- 사용 예시
  - 유사 배열 객체에서 배열 메서드를 사용하는 경우에 사용할 수 있다.
    - arguments 객체는 실제 배열이 아니므로 pop(), shift() 같은 표준 메서드를 사용할 수 없지만, apply() 메서드로 Array를 this로 매핑해주면 표준 메서드를 사용할 수 있다.

    ```jsx
    arguments.shift();  // 에러 발생
    Array.prototype.slice.apply(arguments); // 배열 표준 메서드 사용 가능
    ```

참고 ) [https://velog.io/@realryankim/JavaScript-this란](https://velog.io/@realryankim/JavaScript-this%EB%9E%80)

이들 모두는 Function.prototype 의 메소드이다. 
Call, Apply는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다.

call - 리스트 형식으로 전달, 함수 호출
- 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.

apply - 배열로 묶어 전달, 함수 호출
- 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.

bind - this로 사용할 객체만 전달, 함수 호출하지 않음
- 함수를 어떻게 호출했는지 상관하지 않고 this의 값을 설정할 수 있다.
- 메서드의 this와 메서드 내부의 중첩함수 또는 콜백함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.

call 메서드

- call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령어입니다. call 메서드의 첫번째 인자를 this로 바인딩하고, 이후 인자들을 호출한 함수의 매개변수로 넘깁니다

apply 메서드

- call 메서드와 비슷하게 동작하지만, apply는 call과 다르게 두번째 인자를 배열로 받아 그대로 호출한 함수의 매개변수로 넘깁니다.

bind 메서드

- ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this와 인수를 바탕으로 새로운 함수를 실행하지는 않고 특수 객체를 반환하기만 합니다
- bind한 함수의 name 프로퍼티를 출력하면 bound라는 접두어가 붙습니다. 이로 인해 코드 추적이 더 쉬워집니다.

- call, apply, bind 메서드는 Function.prototype의 메서드이다. 즉, 이들 메서드는 모든 함수가 상속받아 사용할 수 있다.

- call 메서드와 apply 메서드 공통점
  - 본질적인 기능은 함수를 호출하는 것
  - 함수를 호출하면 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩
  - call 메서드와 apply 메서드는 인수를 전달하는 방식만 다를 뿐 동일하게 동작
  - 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우
- call 메서드
  - 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달 `ex) getThisBinding.call(thisArg, 1, 2, 3)`
- apply 메서드
  - 호출할 함수의 인수를 배열로 묶어 전달 `ex) getThisBinding.call(thisArg, [1, 2, 3])`
- bind 메서드
  - 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용


## <a name="3"></a>객체의 메서드를 외부 변수에 할당하거나 함수의 인수로 전달하면 바인딩된 this가 사라지는 이유를 설명하세요.
외부 변수에 할당하는 경우
- 객체의 메서드가 외부 변수의 레퍼런스에 할당되는 순간 this가 가리키던 객체가 사라지며, 전역 객체를 가리키게 된다.
- 객체 메서드의 this는 메서드를 호출한 객체를 가리키지만, 외부 변수에 할당하여 그 변수에 담긴 함수를 호출하면 메서드가 위치한 객체에서 호출한 것이 아니라, 객체 외부 window 영역에서 호출한 것이기 때문에 this는 window를 가리키게 된다.

함수의 인수로 전달하는 경우
- 객체의 메서드가 함수의 인수로 전달될 때는, 객체의 메서드가 아닌 함수 그 자체로 전달된다. 따라서 더이상 this가 해당 객체를 바라보지 않게 되고, 따로 this를 정의하지 않을 경우 전역 객체를 참조하게 된다.

this는 함수의 호출 방식에 따라 동적으로 결정되기 때문에 함수가 외부 변수에 할당되거나 함수의 인수로 전달하면 this가 가리키던 객체가 사라지게 된다.

원래는 객체 내에 있던 함수였기에 메서드로서 동작하던 함수였지만, 외부 변수에 할당되는 순간 해당 함수는 일반 함수가 되므로, 이제는 일반 함수처럼 this가 전역에 바인딩 되는게 아닐까 생각합니다.
함수의 인수로 전달되는 함수의 경우는 callback 함수라고 생각할 수 있을 것 같고, 그렇게되면 callback의 제어권을 가진 함수가 정해준 this가 없다면, this는 전역을 가리키므로 this가 사라졌다고 생각할 수 있을 것 같습니다.


객체의 메서드에 접근하면 함수가 아닌 참조 타입 값을 반환하는데, 외부 변수에 할당하거나 함수의 인수로 전달하는 경우 참조 타입을 버리고 값(함수)만 받아 전달한다. 이 때문에 점 이외의 연산에서는 this의 정보가 사라진다.

## <a name="4"></a>생성자 함수의 동작 방식을 this와 함께 설명해주세요.
new 연산자로 클래스를 호출하는 순간 내부에 정의한 메서드가 들어있는 객체(인스턴스)가 생성되고, constructor()가 자동 호출된다.
이때 constructor 내부에서 선언한 클래스 필드(프라퍼티)는
새로 생성되어 반환되는 객체, 즉 인스턴스를 가리키는 this에 바인딩이 된다.

빈 객체를 만들어 this에 할당한다.
함수 본문을 실행한다.
this에 새로운 property를 추가해 this를 수정한다.
this를 반환한다.
```javascript
function User(name) {
 // this = {};

 // 새로운 프로퍼티를 this에 추가
 this.name = name;
 this.isAdmin = false;

 // return this; (this의 암시적 반환)
}
```

- 기존 함수에서 new 키워드를 사용하여 호출하면, 해당 함수는 생성자 함수로 동작합니다. 그리고 생성자 함수 안의 this는 생성 될 인스턴스 객체를 가리킵니다.
- 생성자 함수로 화살표 함수는 사용할 수 없습니다. 왜냐하면 생성자 함수는 `prototype 프로퍼티`를 가지고, 이 `prototype 프로퍼티`는 프로토타입 객체의 constructor를 사용합니다. 하지만 화살표 함수는 `prototype 프로퍼티`를 가지고 있지 않기 때문에 생성자 함수로 사용할 수 없습니다.

```javascript
function User(name) {
	// 1. 빈 객체가 암시적으로 만들어짐
  // this = {};

  // 2. 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // 3. this가 암시적으로 반환됨
  // return this;
}

```

- 빈 객체를 만들어 this에 할당한다
- 함수 본문을 실행하고, this에 새로운 프로퍼티를 추가해 this를 수정한다.
- this를 반환한다.

`new`를 통해 객체를 생성하면, 자바스크립트에서는 `this`를 생성된 인스턴스로 할당한다. 따라서 생성자는 빈 객체인 `this`를 가지게 된다. 
이후 인스턴스 내부의 메소드는 `this.[메소드명]`을 통해 생성자의 멤버변수나 다른 메서드를 사용할 수 있다.

## 


## <a name="5"></a>this 바인딩에 대해서 아는대로 설명하세요.
식별자 역할을 하는 this와 객체를 묶는 것을 바인딩이라고 한다.
함수 호출 방식에 따라 4가지로 결정된다. 
- 일반함수 호출: 엄격모드가 아닐 때, 일반 함수 내부에서의 `this`는 글로벌 객체와 바인딩된다.
- 메서드 호출: 메서드 내부에서의 `this`는 메서드를 호출한 객체와 바인딩된다.
- 생성자함수 호출: 생성자 함수 내부에서 `this`는 생성자 함수가 생성할 인스턴스와 바인딩된다.
- 명시적 호출: Call, Apply, Bind 메서드 사용 시, 메서드에 첫 번째 인수로 전달하는 객체에 바인딩 된다.

생성자 -> 명시적 -> 암시적 -> 기본 순으로 우선 순위를 가진다.

바인딩은 식별자와 값을 연결하는 과정이다.
JS 의 this는 함수가 호출되는 방식에 따라 this 바인딩이 `동적`으로 결정된다.
- **일반 함수를 호출**하면 전역 객체가 this에 바인드되고,
- **메서드를 호출**하면 메서드를 호출한 객체가 this에 바인드 되고,
- **생성자 함수를 호출**하면 생성자 함수가 미래에 생성할 인스턴스가 this에 바인드되고,
- **function.prototype.call, apply, bind**를 사용해 간접적으로 호출하면 각기의 함수들이 메서드에 첫번째 인수로 전달할 객체가 this에 바인드된다.

this 바인딩이란, this가 가리킬 객체를 정해주는 과정입니다. 자바스크립트에서 this는 함수가 어떻게 호출되는지에 따라, 즉 함수의 실행 컨텍스트에 따라 동적으로 this가 결정됩니다.

함수가 호출되는 방법으로는 크게 4가지가 있습니다.
  
1. 일반 함수로 호출
    - 어떤 함수를 함수로서 호출했을 때는, 호출한 주체가 없기때문에(개발자가 코드로 호출) this가 지정되지 않습니다. 따라서 this가 지정되지 않았기에 this는 전역 객체를 가리킵니다.

2. 메소드로 호출
    - this에는 호출한 주체에 대한 정보가 담긴다. 즉, 메서드로서 호출된 함수의 경우 해당 함수명 앞의 객체가 곧 this가 됩니다.

3. 생성자 함수로 호출
    - 기존 함수에서 new 키워드를 사용하여 호출하면, 해당 함수는 생성자 함수로 동작합니다. 그리고 생성자 함수 안의 this는 생성 될 인스턴스 객체를 가리킵니다.

4. apply/call/bind로 호출
    - this에 원하는 값을 바인딩하기 위해, 명시적으로 this를 바인딩하여 함수를 호출합니다. 세 방식 모두 this로 바인딩 하고 싶은 값을 첫번째 인자로 넣으면, 이후 함수의 this에 원하는 값이 바인딩 됩니다.

- this 바인딩이란 식별자 역할을 하는 this와 this가 가리킬 객체를 바인딩하는 것입니다. this 바인딩은 함수가 어떻게 호출되었는지에 따라 동적으로 결정됩니다. 함수 호출 방식은 3가지로 일반 함수 호출, 메서드 호출, 생성자 함수 호출, 등이 있습니다.
- 먼저, 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this는 전역 객체에 바인딩됩니다. 다음으로 메서드 호출의 경우, 메서드 내부의 this는 해당 메서드를 호출한 객체에 바인딩됩니다. 생성자 함수 호출의 경우, 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩됩니다.

## <a name="6"></a>화살표 함수에서의 this에 대해 설명해주세요.
- 동적으로 함수 호출 시 this가 결정되는 다른 함수와는 달리 화살표 함수는 자신의 this가 없다.
- 대신 화살표 함수를 둘러싸는 렉시컬 범위(lexical scope) 컨텍스트안의 this값을 사용한다.
- 상위 스코프의 this를 바인딩 하는 것처럼 보여 어휘적 this, 렉시컬 this라고도 부른다.
- 화살표 함수는 생성자 함수를 사용할 수 없다.
- 화살표함수에서는 this가 존재하지 않는다. 만약 화살표 함수에 this가 있다면, 이는 화살표 함수 밖의 렉시컬 범위 안에서의 this를 사용한다. 함수 내부에 this가 없기 때문에 화살표 함수는 생성자 함수를 사용할 수 없다.
- 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정됩니다. 화살표 함수는 실행 컨텍스트가 생성될 때 `this` 바인딩이 되지 않고 스코프 체인을 타고 올라가  `상위 스코프 this`를 가리키는데, 이를 `렉시컬 this`라고 합니다.
- 화살표 함수는 call, apply, bind 메소드를 사용하여 this를 변경할 수 없습니다.
- 화살표 함수로 객체의 메서드를 표현하는 것은 바람직 하지 않습니다. 왜냐하면, 화살표 함수의 this는 상위 스코프의 this, 즉 해당 메서드를 포함한 객체의 상위 스코프의 this를 가리키기 때문입니다.
```js
  const person = {
    name: 'Lee',
    sayHi: () => console.log(`Hi ${this.name}`)
  };

  person.sayHi(); // Hi undefined
```
- 화살표 함수는 함수 자체의 this 바인딩을 갖지 않습니다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조합니다. 그리고 이것을 lexical this라고 합니다.

