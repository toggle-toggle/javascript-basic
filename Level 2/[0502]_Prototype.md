# Prototype

## 목차

- [속성의 가려짐'이 무엇인지 설명해주세요.](#1)
- [prototype 프로퍼티, **proto** 프로퍼티, constructor 프로퍼티에 대해 설명해주세요.](#2)
- [프로토타입 체인에 대해서 아는대로 설명해주세요.](#3)
- [프로토타입은 무엇인가요? 자바스크립트에서 프로토타입의 역할에 대해서 설명해주세요.](#4)
- [js class 상속을 prototype 상속과 관련지어 설명하세요.](#5)
- [Prototype기반 상속을 어떻게 하는지 설명해주세요.](#6)

---

## <a name="1"></a>'속성의 가려짐'이 무엇인지 설명해주세요.

- 프로토타입 체인에서 객체 프로퍼티는 '뒤에 있는' 객체가 소유한 같은 이름의 프로퍼티를 오버라이딩한다.
  앞(현재 객체와 가까운 쪽)에 있는 프로퍼티를 먼저 찾으면 뒤(현재 객체와 먼쪽)에 있는 프로퍼티는 숨겨지므로 접근할 수 없다.
  자식 클래스에서 부모 클래스에 선언된 메서드들과 같은 이름의 메서드를 선언하게 되면 상속받은 메서드가 아닌 자식 클래스의 메서드를 사용되게 된다.

- 자식 클래스는 부모 클래스에 선언된 메서드들을 대부분 그대로 상속받습니다. 하지만, 자식 클래스에서 부모 클래스에 선언된 메서드와 같은 이름의 메서드를 선언하게 되면 자식 클래스는 본인이 가지고 있는 메서들르 사용합니다. 이를 메서드 오버라이딩이라고 합니다.

- prototype chain에서 제일 얕은 속성이 더 깊은 속성들을 가린다는 것을 뜻한다.
  method overriding이라고도 한다.

- 특정 객체에서 프로퍼티를 참조할 때에는 프로토타입 체인을 따라 탐색한다. 이때, 체인 상에 key가 같은 프로퍼티가 존재할 경우 처음 객체를 기준으로 가장 먼저 도달하는 프로토타입을 우선적으로 탐색하므로 더 상위의 프로토타입에 존재하는 프로퍼티는 자연스럽게 무시된다. 이러한 현상을 속성의 가려짐이라고 한다.

## <a name="2"></a>prototype 프로퍼티, **proto** 프로퍼티, constructor 프로퍼티에 대해 설명해주세요.

- prototype 프로퍼티
  - 자신의 프로토타입 객체
  - 하위로 물려줄 프로토타입의 정보
- proto 프로퍼티
  - 더블 언더스코어 프로토의 약어인 던더 프로토(dunder proto)라고 한다.
  - 상위에서 물려 받은 객체의 프로토타입에 대한 정보
  - 객체 프로토타입을 읽고 설정하는 특별한 프로퍼티이다.
  - [[Prototype]]는 숨김 프로퍼티이기 때문에 직접 접근할 수가 없어서 이 ** proto **가 [[Prototype]]에 접근한다.
- constructor 프로퍼티

  - 모든 인스턴스에는 메서드가 저장된 공통 프로토타입 객체가 있고, constructor 프로퍼티는 그 객체를 가리킨다.
  - 모든 인스턴스는 프로토타입에서 constructor 프로퍼티를 상속하므로 인스턴스를 알아내는 데 사용할 수 있다.
  - 그 공통 프로토타입 객체는 모든 인스턴스의 프로토타입이 된다.

- 모든 객체는 [[Prototype]] 내부 슬롯을 가지고, 이 내부 슬록은 프로토타입을 가리킵니다. 하지만 [[Prototype]]에 직접 접근 할 수 없어서 ** proto** 접근자 프로퍼티를 통해 프로토타입 객체에 접근합니다.
- prototype 프로퍼티는 함수 객체만이 가지는 프로퍼티입니다. new 키워드를 통해 함수가 생성자로 사용될 때, 생성된 객체의 프로토타입 객체를 가리킨다.
- constructor 프로퍼티는 프로토타입 객체가 가지는 프로퍼티입니다. 프로토타입 객체를 생성한 객체를 가리킵니다.

- constructor에는 이 프로토타입 객체가 생성될 때 선언했던 함수가 들어있다.
- ** proto ** : 객체가 생성될 때의 조상 함수인 prototype object를 가리킨다.
- prototype : 본인이 가진 객체를 말한다.

- proto
  - [[Prototype]]에 대한 접근자 프로퍼티(getter, setter)
  - 최근에는 setPrototypeOf, getPrototypeOf로 대체
- prototype
  - 함수가 가지고 있는 프로퍼티
  - prototype의 값이 객체이면 해당 함수를 통해 생성된 객체의 프로토타입을 prototype의 값으로 설정한다.
  - prototype은 기본적으로 constructor프로퍼티 하나만 있는 객체를 가리킨다.
    이때, constructor는 함수 자기 자신을 가리킨다.

## <a name="3"></a>프로토타입 체인에 대해서 아는대로 설명해주세요.

- 객체는 자신의 프로토타입 프로퍼티를 모두 상속하고, 자신의 프로토타입을 내부 프로퍼티인 [[Prototype]]에 기록한다.
- 객체와 그 [[Prototype]] 프로퍼티를 묶는 체인을 프로토타입 체인이라고 한다.
- 객체에서 어떤 기능을 호출할 때, 현재 객체에서 해당 속성을 찾고, 찾지 못할 경우 상위로 올라가면서 찾게 되는데 이 반복되는 체이닝을 프로토타입 체인이라고 한다.
- 그 객체의 프로토타입도 프로토타입을 가지고 있기 때문에, 이것이 상위로 반복되다가 더이상 프로토타입이 없을 때 프로토타입 체인의 종점인 null을 가리키게 된다.
- 객체의 proto를 타고 올라가다가, 기본적으로 함수의 prototype 속성의 proto가 window.Object.prototype이기 때문에 여기까지 와서 속성을 찾고, 여기에서도 없어서 한번 더 올라가면 window.Object.prototype의 proto를 찾으면 window.Object.prototype의 proto는 null이기 때문에 모든 프로토타입 체인이 검사 되고 브라우저가 더이상 검사할 proto가 없을때에서야 브라우저는 우리가 찾던 값이 undefined라고 결론짓는다.
- 프로토타입 체이닝으로 속성을 탐색하는 것은 성능에 나쁜 영향을 줄 수 있습니다. 따라서 Object.prototype에서 모든 오브젝트로 상속된 hasOwnProperty 메서드를 이용하는 것이 좋다.
- 프로토타입 체인의 길이는 성능을 저해하지 않도록 줄이는 방법을 고안해야 한다

- 자바스크립트가 특정 객체의 프로퍼티, 메소드에 접근하려하는데 없다면, [[Prototype]]이 가리키는 링크를 따라 프로토타입 객체의 프로퍼티, 메소드를 차례대로 검색한다. 이때 사용되는 게 프로토타입 체인입니다.

- 프로토타입으로 이루어진 객체들의 관계를 프로토타입 체인이라고 한다.
- 연결 고리가 이어져 상속 관계를 통하여 상위 프로토타입으로 연속해서 이어지는 관계를 프로토타입 체인이라고 한다.

- 자바스크립트의 객체에서 프로퍼티를 읽으려 시도할 때 해당 프로퍼티가 없으면 프로토타입으로 참조하고 있는 객체에서 이 프로퍼티를 찾는다.
- 같은 방식으로 프로퍼티 탐색을 반복한다.
- 가장 상위의 프로토타입까지 탐색했음에도 없을 경우 undefined가 된다.
- 객체에 프로퍼티를 '쓰려고' 시도할 때에는 프로토타입에 같은 이름의 프로퍼티가 있어도 영향을 주지않는다.(현재 객체에만 추가)
- 프로토타입에 setter로 선언되어 있을 경우 해당 setter를 실행한다.

## <a name="4"></a>프로토타입은 무엇인가요? 자바스크립트에서 프로토타입의 역할에 대해서 설명해주세요.

- 자바스크립트에서 각각의 객체는 [[Prototype]]이라는 은닉(private) 속성을 가지는데 자신의 프로토타입이 되는 다른 객체를 가리킨다. 즉, [[Prototype]]이 참조하는 객체를 '프로토타입’이라고 합니다.
- 자바스크립트는 프로토타입 기반의 언어다. 자바스크립트는 프로토타입을 기반으로 '상속'이라는 개념을 제공한다.

- 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어가 아닌 프로토타입 기반 객체지향 프로그래밍 언어입니다. 자바스크립트의 모든 객체는 부모 객체와 연결이 되어있고, 부모 객체의 프로퍼티, 메소드를 상속받아 사용할 수 있습니다. 이러한 부모 객체를 Prototype(객체) 라고 합니다.

- 객체는 함수를 사용해서 만들어지고, 객체는 함수의 프로토타입 객체를 복제하여 생성된다.
- 모든 객체는 자신이 어떤 원본 객체를 복제하여 생성된 것인지에 대한 정보를 가지고 있다.

- 자바스크립트의 객체는 [[Prototype]]이라는 숨김 프로퍼티를 갖는다.
- [[Prototype]]는 null이거나 다른 객체에 대한 참조
- 다른 객체를 참조할 때 그 참조 대상을 '프로토타입'이라고 부른다.

## <a name="5"></a>js class 상속을 prototype 상속과 관련지어 설명하세요.

- 자바스크립트에는 '상속'이라는 개념이 없지만, prototype으로 상속을 구현할 수 있다.
- js class 상속은 extends 라는 키워드로 구현할 수 있는데, 다른 클래스의 메서드를 상속받아 그대로 사용할 수 있으며, 원하는 기능을 추가하여 사용할 수도 있다. 이 extends키워드는 프로토타입을 기반으로 동작한다.
- object에서 프로퍼티를 읽으려고 할 때, 해당 프로퍼티가 없으면 자바스크립트는 자동으로 프로토타입에서 프로퍼티를 찾는다. 프로그래밍에선 이런 동작 방식을 '프로토타입 상속’이라 부른다.
- 클래스의 상속 기능 자체가 프로토타입을 기반으로 구성되어 있기 때문에 프로토타입의 방식과 동일하게 동작한다.
- 객체엔 오직 하나의 `[[Portotype]]`만 있을 수 있다. 객체는 두 개의 객체를 상속받지 못한다.
- es6부터 클래스가 등장했지만, 자바스크립트는 프로토타입 기반 프로그래밍 언어이기 때문에 클래스의 방식으로 새롭게 상속을 하는 것이 아니라 여전히 '프로토 타입' 기반으로 상속을 한다.

```jsx
상속을 해주기위한 부모 클래스 Person
상속을 받은 자식 클래스 Shinsehantan
```

- extends는 Shinsehantan.prototype.[[Prototype]]을 Person.prototype으로 설정한다. 그렇기 때문에 프로토타입에서 동작하는 것과 같이 프로퍼티나 메서드를 찾을 때 Shinsehantan.prototype에서 먼저 탐색 후 찾지 못하면 상위 프로토타입에서 찾게 된다.

- 자바스크립트는 프로토타입 기반의 객체지향 언어입니다. es6에서 class가 등장하였지만, 그렇다고 해서 class기반으로 상속이 동작하지는 않고, 여전히 prototype을 기반으로 상속을 진행합니다. 자바스크립트에서 class 상속은 extends 키워드를 사용하고, constructor에서 사용한 super() 함수가 상속받은 클래스의 생성자를 가르킵니다.

- 자바스크립트에서의 상속은 사실 상속이라고 보기 보다는 확장으로 볼 수있다. ES6부터 Class 개념이 등장했지만, 이도 결국 prototype을 통해 객체를 연결시켜주고 있다.
- 이렇게 객체를 연결시켜주기 때문에, 어떤 메소드를 찾을 때, 자신에게 없으면 자신을 만든 상위 객체에서 메소드를 찾게 된다.

- extends 키워드를 통해 상속가능
- 자식 생성자의 prototype 프로퍼티가 참조하고 있는 객체의 프로토타입을 부모 생성자의 prototype 프로퍼티로 설정

## <a name="6"></a>Prototype기반 상속을 어떻게 하는지 설명해주세요.

prototype 상속에는 위임형, 연결형, 함수형 상속 3가지 종류가 있다.

- 위임형 상속(Delegation inheritance)
  - 위임형 상속에서 프로토타입 객체는 다른 객체의 기반이 된다. 위임 프로토타입을 상속받을 경우 새 객체는 해당 프로토타입에 대한 참조를 가지고 있다.
  - 메소드를 위임 상속할 경우 모든 객체가 각 메소드에에 대해 하나의 코드를 공유하므로 메모리를 절약할 수 있다.
- 연결형 상속(Concatenative inheritance)
  - `[Object.assign()]`을 통해 구현하며, 연결형 상속은 한 객체의 속성을 다른 객체에 모두 복사함으로써 상속을 구현하는 방법이다.
  - 이 상속법은 Javascript 객체의 동적 확장성을 이용한 방법이다.
  - 객체 복사는 속성의 초기값을 저장하기 위한 좋은 방법이다:
- 함수형 상속(Functional inheritance)

  - Douglas Crockford가 창조한 단어이고, 새 속성들을 연결형 상속으로 쌓되 상속 기능을 Factory 함수로 만들어 사용하는 방식을 말한다.
  - 기존의 객체를 확장하는데 쓰이는 함수를 일반적으로 믹스인 함수라 칭하는데, 객체 확장에 함수를 사용하는 가장 큰 이점은 Private Data를 클로져를 통해 캡슐화 시킬 수 있다는 것이다. (Private 상태를 지정할 수 있다는 의미)

- 자바스크립트의 객체는 [[Prototypr]]이라는 내부 슬롯을 가지고, 이는 프로토타입 객체를 가릌킵니다. 자바스크립트는 객체에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없으면 자동으로 프로토타입 객체에서 프로퍼티를 찾습니다. 그리고 또 찾지못하면 프로토타입 체인을 타고 올라가면서 계속해서 찾는데 이러한 동작 방식을 프로토타입 상속이라고 합니다.

- 생성자 함수 내에서 this를 사용하지 않고, 원본 객체에 메소드나 프로퍼티를 적용하게되면 객체들에게는 해당 프로퍼티가 없지만, 원본 객체의 프로퍼티나 메소드를 참조한다.

- 생성자의 prototype프로퍼티를 지정
  → 이때 constructor는 자기 자신으로 유지
- Object.create를 이용
- 여러 객체를 상속받을때에는 mixin 활용
